#!/usr/bin/env bash
#
# flywheel - Cross-platform installer for Dicklesworthstone's Agentic Coding Flywheel
# Mirrors ACFS functionality for macOS/Linux/WSL (no VPS required)
# https://agent-flywheel.com/tldr
#
# Usage:
#   ./flywheel install   # Install all tools
#   ./flywheel doctor    # Health check
#   ./flywheel update    # Update tools
#   ./flywheel missing   # Show what's missing

set +e
VERSION="2.5.2"

# Colors
if [[ -t 1 ]]; then
    RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'
    BLUE='\033[0;34m'; CYAN='\033[0;36m'; BOLD='\033[1m'; NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' CYAN='' BOLD='' NC=''
fi

detect_platform() {
    case "$(uname -s)" in
        Darwin*)  PLATFORM="macos" ;;
        Linux*)   [[ -f /proc/version ]] && grep -qi microsoft /proc/version && PLATFORM="wsl" || PLATFORM="linux" ;;
        *)        PLATFORM="unknown" ;;
    esac
    case "$(uname -m)" in
        x86_64|amd64)  ARCH="amd64" ;;
        arm64|aarch64) ARCH="arm64" ;;
        *)             ARCH="unknown" ;;
    esac
    # Detect package manager
    if command -v brew &>/dev/null; then
        PKG_MGR="brew"
    elif command -v apt &>/dev/null; then
        PKG_MGR="apt"
    elif command -v dnf &>/dev/null; then
        PKG_MGR="dnf"
    elif command -v pacman &>/dev/null; then
        PKG_MGR="pacman"
    else
        PKG_MGR="unknown"
    fi
}

# Cross-platform package install helper
pkg_install() {
    local pkg=$1
    local apt_pkg=${2:-$1}
    local dnf_pkg=${3:-$apt_pkg}
    local pacman_pkg=${4:-$dnf_pkg}

    case "$PKG_MGR" in
        brew)   brew install "$pkg" 2>/dev/null ;;
        apt)    sudo apt install -y "$apt_pkg" ;;
        dnf)    sudo dnf install -y "$dnf_pkg" ;;
        pacman) sudo pacman -S --noconfirm "$pacman_pkg" ;;
        *)      echo "Unknown package manager. Install $pkg manually." && return 1 ;;
    esac
}

has() {
    command -v "$1" &>/dev/null && return 0
    [[ -x "$HOME/go/bin/$1" ]] && return 0
    [[ -x "$HOME/.local/bin/$1" ]] && return 0
    [[ -x "$HOME/.cargo/bin/$1" ]] && return 0
    [[ -x "/opt/homebrew/bin/$1" ]] && return 0
    return 1
}

print_header() {
    echo ""
    echo -e "${BOLD}${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}${CYAN}║     AGENTIC CODING FLYWHEEL v$VERSION                          ║${NC}"
    echo -e "${BOLD}${CYAN}║     https://agent-flywheel.com/tldr                          ║${NC}"
    echo -e "${BOLD}${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "  Platform: ${BLUE}$PLATFORM${NC} ($ARCH) | Package Manager: ${BLUE}$PKG_MGR${NC}"
    echo ""
}

run_doctor() {
    print_header
    local installed=0 missing=0

    check() {
        local name=$1 cmd=$2 cat=$3
        if has "$cmd"; then
            echo -e "  ${GREEN}✓${NC} $name"
            installed=$((installed + 1))
        else
            echo -e "  ${RED}✗${NC} $name"
            missing=$((missing + 1))
        fi
    }

    echo -e "${BOLD}Prerequisites:${NC}"
    check "tmux" "tmux" "prereq"
    check "fzf" "fzf" "prereq"
    check "git" "git" "prereq"
    check "jq" "jq" "prereq"
    check "go" "go" "prereq"
    check "bun" "bun" "prereq"
    check "uv" "uv" "prereq"
    check "cargo" "cargo" "prereq"
    echo ""

    echo -e "${BOLD}Shell Enhancements:${NC}"
    check "zoxide" "zoxide" "shell"
    check "atuin" "atuin" "shell"
    echo ""

    echo -e "${BOLD}AI Agents:${NC}"
    check "claude" "claude" "agents"
    check "codex" "codex" "agents"
    check "gemini" "gemini" "agents"
    echo ""

    echo -e "${BOLD}Core Stack:${NC}"
    check "ntm" "ntm" "core"
    check "br" "br" "core"
    check "bv" "bv" "core"
    check "cass" "cass" "core"
    check "cm" "cm" "core"
    echo ""

    echo -e "${BOLD}Safety Tools:${NC}"
    check "dcg" "dcg" "safety"
    check "ubs" "ubs" "safety"
    check "slb" "slb" "safety"
    check "pt" "pt" "safety"
    echo ""

    echo -e "${BOLD}Productivity:${NC}"
    check "ms" "ms" "productivity"
    check "s2p" "s2p" "productivity"
    check "ru" "ru" "productivity"
    check "apr" "apr" "productivity"
    check "caam" "caam" "productivity"
    check "xf" "xf" "productivity"
    echo ""

    echo -e "${BOLD}Utilities:${NC}"
    check "csctf" "csctf" "utilities"
    check "tru" "tru" "utilities"
    check "rano" "rano" "utilities"
    check "giil" "giil" "utilities"
    check "brenner" "brenner" "utilities"
    echo ""

    echo -e "${BOLD}Services:${NC}"
    # Check multiple possible locations for MCP Agent Mail
    local mail_dir=""
    if [[ -d "$HOME/mcp_agent_mail" ]]; then
        mail_dir="$HOME/mcp_agent_mail"
    elif [[ -d "$HOME/Developer/mcp_agent_mail" ]]; then
        mail_dir="$HOME/Developer/mcp_agent_mail"
    elif [[ -d "$HOME/.mcp-agent-mail" ]]; then
        mail_dir="$HOME/.mcp-agent-mail"
    fi
    local mail_db="$mail_dir/storage.sqlite3"
    local mail_wal="$mail_dir/storage.sqlite3-wal"
    local mail_shm="$mail_dir/storage.sqlite3-shm"
    local mail_status="unknown"
    local mail_issue=""

    # Step 0: Check if mail_dir was found
    if [[ -z "$mail_dir" ]]; then
        mail_status="not_installed"
        mail_issue="MCP Agent Mail not installed"
    fi

    # Step 1: Check for orphaned WAL/SHM files (main db deleted but residuals remain)
    if [[ "$mail_status" == "unknown" ]] && [[ ! -f "$mail_db" ]] && { [[ -f "$mail_wal" ]] || [[ -f "$mail_shm" ]]; }; then
        mail_status="orphaned"
        mail_issue="Orphaned WAL/SHM files without main database"
    fi

    # Step 2: Check if server process is running and database is accessible
    if [[ "$mail_status" == "unknown" ]]; then
        local mail_pid=$(pgrep -f "mcp_agent_mail" 2>/dev/null | head -1)

        if [[ -n "$mail_pid" ]]; then
            # Process is running, check database health
            if [[ -f "$mail_db" ]]; then
                if sqlite3 "$mail_db" "SELECT 1 FROM sqlite_master LIMIT 1;" &>/dev/null; then
                    mail_status="healthy"
                else
                    mail_status="corrupted"
                    mail_issue="Database file is corrupted"
                fi
            else
                # Process running, no database yet - that's fine (fresh state)
                mail_status="healthy"
            fi
        else
            # No process found via pgrep - try HTTP health check as fallback
            # (handles WSL cross-distro, Windows-side processes, etc.)
            if curl -s --connect-timeout 2 -o /dev/null "http://localhost:8765/api/health" 2>/dev/null; then
                mail_status="healthy"
            elif [[ -n "$mail_dir" ]] && [[ -d "$mail_dir" ]]; then
                mail_status="not_running"
            else
                mail_status="not_installed"
                mail_issue="MCP Agent Mail not installed"
            fi
        fi
    fi

    # Display status
    case "$mail_status" in
        healthy)
            echo -e "  ${GREEN}✓${NC} MCP Agent Mail (running)"
            ;;
        not_running)
            echo -e "  ${YELLOW}○${NC} MCP Agent Mail (not running)"
            echo -e "      Start with: ${CYAN}cd $mail_dir && uv run python -m mcp_agent_mail.cli serve-http &${NC}"
            ;;
        not_installed)
            echo -e "  ${YELLOW}○${NC} MCP Agent Mail (not installed)"
            ;;
        orphaned)
            echo -e "  ${RED}✗${NC} MCP Agent Mail ($mail_issue)"
            echo -e "      Fix with: ${CYAN}flywheel fix${NC}"
            ;;
        corrupted)
            echo -e "  ${RED}✗${NC} MCP Agent Mail ($mail_issue)"
            echo -e "      Fix with: ${CYAN}flywheel fix${NC}"
            ;;
    esac

    # Check Mail Server Web GUI endpoints (only if server is running)
    if [[ "$mail_status" == "healthy" ]]; then
        echo -e "${BOLD}Mail Server Web GUI:${NC}"
        local mail_gui_ok=0 mail_gui_fail=0

        check_mail_endpoint() {
            local name=$1 path=$2
            local url="http://localhost:8765${path}"
            if curl -s -o /dev/null -w "%{http_code}" "$url" 2>/dev/null | grep -qE "^(200|302)$"; then
                echo -e "  ${GREEN}✓${NC} $name"
                mail_gui_ok=$((mail_gui_ok + 1))
            else
                echo -e "  ${RED}✗${NC} $name (not responding)"
                mail_gui_fail=$((mail_gui_fail + 1))
            fi
        }

        check_mail_endpoint "API Docs" "/docs"
        check_mail_endpoint "Unified Inbox" "/mail/unified-inbox"
        check_mail_endpoint "Projects List" "/mail/projects"
        check_mail_endpoint "Archive Browser" "/mail/archive/browser"
        check_mail_endpoint "Network View" "/mail/archive/network"
        check_mail_endpoint "Activity Feed" "/mail/archive/activity"

        if [[ $mail_gui_fail -gt 0 ]]; then
            echo -e "      ${YELLOW}Tip:${NC} Open ${CYAN}http://localhost:8765/docs${NC} in browser"
        fi
        echo ""
    fi

    # Determine shell config file
    local rc="$HOME/.zshrc"
    local shell_name="zsh"
    [[ "$SHELL" == */bash ]] && { rc="$HOME/.bashrc"; shell_name="bash"; }

    echo -e "${BOLD}PATH Configuration:${NC}"
    local path_issues=0
    if echo "$PATH" | grep -q "$HOME/.local/bin"; then
        echo -e "  ${GREEN}✓${NC} ~/.local/bin in PATH"
    else
        echo -e "  ${RED}✗${NC} ~/.local/bin not in PATH"
        path_issues=1
    fi
    if echo "$PATH" | grep -q "$HOME/go/bin"; then
        echo -e "  ${GREEN}✓${NC} ~/go/bin in PATH"
    else
        echo -e "  ${YELLOW}○${NC} ~/go/bin not in PATH (needed for: slb)"
    fi
    if echo "$PATH" | grep -q "$HOME/.cargo/bin"; then
        echo -e "  ${GREEN}✓${NC} ~/.cargo/bin in PATH"
    else
        echo -e "  ${YELLOW}○${NC} ~/.cargo/bin not in PATH (needed for: rust tools)"
    fi
    echo ""

    echo -e "${BOLD}Shell Integration:${NC}"
    if [[ -f "$rc" ]]; then
        grep -q 'ntm shell' "$rc" && echo -e "  ${GREEN}✓${NC} NTM shell hooks" || echo -e "  ${YELLOW}○${NC} NTM (add: eval \"\$(ntm shell $shell_name)\")"
        grep -q 'zoxide init' "$rc" && echo -e "  ${GREEN}✓${NC} zoxide" || echo -e "  ${YELLOW}○${NC} zoxide (add: eval \"\$(zoxide init $shell_name)\")"
        grep -q 'atuin init' "$rc" && echo -e "  ${GREEN}✓${NC} atuin" || echo -e "  ${YELLOW}○${NC} atuin (add: eval \"\$(atuin init $shell_name)\")"
    else
        echo -e "  ${RED}✗${NC} Shell config not found: $rc"
    fi
    echo ""

    echo -e "${BOLD}Tool Locations:${NC}"
    for tool in ntm br bv cass cm dcg claude; do
        local loc=$(command -v "$tool" 2>/dev/null)
        if [[ -n "$loc" ]]; then
            # Check if it's a symlink
            if [[ -L "$loc" ]]; then
                local target=$(readlink "$loc" 2>/dev/null || readlink -f "$loc" 2>/dev/null)
                echo -e "  ${GREEN}✓${NC} $tool → $loc → $target"
            else
                echo -e "  ${GREEN}✓${NC} $tool → $loc"
            fi
        fi
    done
    echo ""

    echo -e "${BOLD}Versions:${NC}"
    # Get versions quietly, handle missing tools
    local ver
    ver=$(claude --version 2>/dev/null | head -1) && echo -e "  claude: ${CYAN}$ver${NC}" || true
    ver=$(ntm --version 2>/dev/null | head -1) && echo -e "  ntm: ${CYAN}$ver${NC}" || true
    ver=$(br --version 2>/dev/null | head -1) && echo -e "  br: ${CYAN}$ver${NC}" || true
    ver=$(bv --version 2>/dev/null | head -1) && echo -e "  bv: ${CYAN}$ver${NC}" || true
    ver=$(cass --version 2>/dev/null | head -1) && echo -e "  cass: ${CYAN}$ver${NC}" || true
    echo ""

    echo -e "${BOLD}Auth Status:${NC}"
    # Check Claude auth
    if [[ -f "$HOME/.claude/.credentials.json" ]] || [[ -f "$HOME/.config/claude/credentials.json" ]]; then
        echo -e "  ${GREEN}✓${NC} claude (authenticated)"
    elif has claude; then
        echo -e "  ${YELLOW}○${NC} claude (run: claude to login)"
    fi
    # Check Codex auth
    if [[ -f "$HOME/.codex/auth.json" ]] || [[ -n "$OPENAI_API_KEY" ]]; then
        echo -e "  ${GREEN}✓${NC} codex (authenticated)"
    elif has codex; then
        echo -e "  ${YELLOW}○${NC} codex (run: codex to login)"
    fi
    # Check Gemini auth
    if [[ -f "$HOME/.config/gemini/credentials.json" ]] || [[ -n "$GOOGLE_API_KEY" ]] || [[ -n "$GEMINI_API_KEY" ]]; then
        echo -e "  ${GREEN}✓${NC} gemini (authenticated)"
    elif has gemini; then
        echo -e "  ${YELLOW}○${NC} gemini (run: gemini to login)"
    fi
    echo ""

    echo -e "${BOLD}Active Sessions:${NC}"
    local tmux_sessions=$(tmux list-sessions 2>/dev/null)
    if [[ -n "$tmux_sessions" ]]; then
        echo "$tmux_sessions" | while read -r line; do
            echo -e "  ${BLUE}▶${NC} $line"
        done
    else
        echo -e "  ${YELLOW}○${NC} No tmux sessions running"
    fi
    echo ""

    echo -e "${BOLD}Project Status:${NC}"
    if [[ -d ".beads" ]]; then
        echo -e "  ${GREEN}✓${NC} Task tracking initialized (.beads/)"
        local task_count=$(br list 2>/dev/null | wc -l | tr -d ' ')
        [[ "$task_count" -gt 0 ]] && echo -e "  ${CYAN}$task_count task(s)${NC} in project"
        local ready_count=$(br ready 2>/dev/null | wc -l | tr -d ' ')
        [[ "$ready_count" -gt 0 ]] && echo -e "  ${GREEN}$ready_count task(s) ready${NC} to work on"
    else
        echo -e "  ${YELLOW}○${NC} No task tracking (run: flywheel init)"
    fi
    if [[ -f "AGENTS.md" ]]; then
        echo -e "  ${GREEN}✓${NC} AGENTS.md present"
    else
        echo -e "  ${YELLOW}○${NC} No AGENTS.md (run: flywheel init)"
    fi
    if [[ -d ".claude" ]]; then
        echo -e "  ${GREEN}✓${NC} .claude/ directory present"
    fi
    echo ""

    echo -e "${BOLD}Tool Freshness:${NC}"
    local stale_found=0
    check_stale() {
        local tool=$1 path=$2
        if [[ -f "$path" ]]; then
            local mod_time
            # Linux/WSL uses -c, macOS uses -f
            if [[ "$PLATFORM" == "macos" ]]; then
                mod_time=$(stat -f %m "$path" 2>/dev/null)
            else
                mod_time=$(stat -c %Y "$path" 2>/dev/null)
            fi
            if [[ -n "$mod_time" ]]; then
                local mod_days=$(( ($(date +%s) - mod_time) / 86400 ))
                if [[ $mod_days -gt 30 ]]; then
                    echo -e "  ${YELLOW}○${NC} $tool (${mod_days}d old) - consider updating"
                    stale_found=1
                fi
            fi
        fi
    }
    check_stale "ntm" "$HOME/.local/bin/ntm"
    check_stale "br" "$HOME/.local/bin/br"
    check_stale "dcg" "$HOME/.local/bin/dcg"
    check_stale "cm" "$HOME/.local/bin/cm"
    check_stale "cass" "$HOME/.local/bin/cass"
    [[ $stale_found -eq 0 ]] && echo -e "  ${GREEN}✓${NC} All tools recently updated"
    echo ""

    local total=$((installed + missing))
    echo -e "${BOLD}Summary:${NC} ${GREEN}$installed${NC}/$total tools installed"
    [[ $missing -gt 0 ]] && echo -e "Run ${CYAN}flywheel install${NC} to install missing tools"
    [[ $path_issues -gt 0 ]] && echo -e "Run ${CYAN}flywheel install${NC} to fix PATH issues"
    echo ""
}

run_install() {
    print_header
    echo -e "${BOLD}Installing Agentic Flywheel Tools...${NC}"
    echo ""

    [[ "$PKG_MGR" == "brew" ]] && brew tap dicklesworthstone/tap 2>/dev/null

    # Prerequisites
    has tmux || { echo "Installing tmux..."; pkg_install tmux; }
    has fzf || { echo "Installing fzf..."; pkg_install fzf; }
    has jq || { echo "Installing jq..."; pkg_install jq; }
    has go || { echo "Installing go..."; pkg_install go golang-go golang go; }
    has bun || { echo "Installing bun..."; curl -fsSL https://bun.sh/install | bash; }
    has uv || { echo "Installing uv..."; curl -LsSf https://astral.sh/uv/install.sh | sh; }
    has cargo || { echo "Installing rust..."; curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y; }

    # Shell
    has zoxide || { echo "Installing zoxide..."; brew install zoxide 2>/dev/null || curl -fsSL https://raw.githubusercontent.com/ajeetdsouza/zoxide/main/install.sh | bash; }
    has atuin || { echo "Installing atuin..."; brew install atuin 2>/dev/null || curl -fsSL https://setup.atuin.sh | bash; }

    # AI Agents
    has claude || { echo "Installing claude..."; npm install -g @anthropic-ai/claude-code 2>/dev/null || bun install -g @anthropic-ai/claude-code; }
    has codex || { echo "Installing codex..."; npm install -g @openai/codex 2>/dev/null || bun install -g @openai/codex; }
    has gemini || { echo "Installing gemini..."; npm install -g @google/gemini-cli 2>/dev/null || bun install -g @google/gemini-cli; }

    # Core Stack
    has ntm || { echo "Installing ntm..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/ntm/main/install.sh" | bash -s -- --easy-mode; }
    has br || { echo "Installing br..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/beads_rust/main/install.sh" | bash; }
    has bv || { echo "Installing bv..."; brew install dicklesworthstone/tap/bv 2>/dev/null || curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/beads_viewer/main/install.sh" | bash; }
    has cass || { echo "Installing cass..."; brew install dicklesworthstone/tap/cass 2>/dev/null || curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/coding_agent_session_search/main/install.sh" | bash -s -- --easy-mode; }
    has cm || { echo "Installing cm..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/cass_memory_system/main/install.sh" | bash -s -- --easy-mode; }

    # Safety
    has dcg || { echo "Installing dcg..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/destructive_command_guard/main/install.sh" | bash -s -- --easy-mode; }
    has ubs || { echo "Installing ubs..."; brew install dicklesworthstone/tap/ubs 2>/dev/null || curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/ultimate_bug_scanner/master/install.sh" | bash; }
    has slb || { echo "Installing slb..."; go install github.com/Dicklesworthstone/slb/cmd/slb@latest; }
    has pt || { echo "Installing pt..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/process_triage/master/install.sh" | bash; }

    # Productivity
    has ms || { echo "Installing ms..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/meta_skill/main/scripts/install.sh" | bash; }
    has s2p || { echo "Installing s2p..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/source_to_prompt_tui/main/install.sh" | bash; }
    has ru || { echo "Installing ru..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/repo_updater/main/install.sh" | bash; }
    has apr || { echo "Installing apr..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/automated_plan_reviser_pro/main/install.sh" | bash; }
    has caam || { echo "Installing caam..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/coding_agent_account_manager/main/install.sh" | bash; }
    has xf || { echo "Installing xf..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/xf/main/install.sh" | bash; }

    # Utilities
    has csctf || { echo "Installing csctf..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/chat_shared_conversation_to_file/main/install.sh" | bash; }
    has tru || { echo "Installing tru..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/toon_rust/master/install.sh" | bash; }
    has rano || { echo "Installing rano..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/rano/main/install.sh" | bash; }
    has giil || { echo "Installing giil..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/giil/main/install.sh" | bash; }
    has brenner || { echo "Installing brenner..."; curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/brenner_bot/main/install.sh" | bash; }

    # MCP Agent Mail
    curl -s http://127.0.0.1:8765/health &>/dev/null || {
        echo "Installing MCP Agent Mail..."
        curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/mcp_agent_mail/main/scripts/install.sh" | bash -s -- --yes --no-start
    }

    # Shell integration
    local rc="$HOME/.zshrc"
    local shell_name="zsh"
    [[ "$SHELL" == */bash ]] && { rc="$HOME/.bashrc"; shell_name="bash"; }
    [[ -f "$rc" ]] && {
        grep -q 'ntm shell' "$rc" || echo "eval \"\$(ntm shell $shell_name)\"" >> "$rc"
        grep -q 'zoxide init' "$rc" || echo "eval \"\$(zoxide init $shell_name)\"" >> "$rc"
        grep -q '.local/bin' "$rc" || echo 'export PATH="$PATH:$HOME/.local/bin"' >> "$rc"
        grep -q 'go/bin' "$rc" || echo 'export PATH="$PATH:$HOME/go/bin"' >> "$rc"
    }

    echo ""
    echo -e "${GREEN}Installation complete!${NC} Run: source $rc && flywheel doctor"
}

show_missing() {
    print_header
    echo -e "${BOLD}Missing Tools:${NC}"
    echo ""

    show() {
        local name=$1 cmd=$2 install=$3
        has "$cmd" || { echo -e "${YELLOW}$name:${NC}"; echo -e "  ${CYAN}$install${NC}"; echo ""; }
    }

    show "tmux" "tmux" "brew install tmux"
    show "fzf" "fzf" "brew install fzf"
    show "go" "go" "brew install go"
    show "bun" "bun" "curl -fsSL https://bun.sh/install | bash"
    show "uv" "uv" "curl -LsSf https://astral.sh/uv/install.sh | sh"
    show "cargo" "cargo" "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh"
    show "zoxide" "zoxide" "brew install zoxide"
    show "atuin" "atuin" "brew install atuin"
    show "claude" "claude" "npm install -g @anthropic-ai/claude-code"
    show "codex" "codex" "npm install -g @openai/codex"
    show "gemini" "gemini" "npm install -g @google/gemini-cli"
    show "ntm" "ntm" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/ntm/main/install.sh | bash -s -- --easy-mode"
    show "br" "br" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/beads_rust/main/install.sh | bash"
    show "bv" "bv" "brew install dicklesworthstone/tap/bv"
    show "cass" "cass" "brew install dicklesworthstone/tap/cass"
    show "cm" "cm" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/cass_memory_system/main/install.sh | bash"
    show "dcg" "dcg" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/destructive_command_guard/main/install.sh | bash -s -- --easy-mode"
    show "ubs" "ubs" "brew install dicklesworthstone/tap/ubs"
    show "slb" "slb" "go install github.com/Dicklesworthstone/slb/cmd/slb@latest"
    show "pt" "pt" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/process_triage/master/install.sh | bash"
    show "ms" "ms" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/meta_skill/main/scripts/install.sh | bash"
    show "s2p" "s2p" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/source_to_prompt_tui/main/install.sh | bash"
    show "ru" "ru" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/repo_updater/main/install.sh | bash"
    show "apr" "apr" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/automated_plan_reviser_pro/main/install.sh | bash"
    show "caam" "caam" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/coding_agent_account_manager/main/install.sh | bash"
    show "xf" "xf" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/xf/main/install.sh | bash"
    show "csctf" "csctf" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/chat_shared_conversation_to_file/main/install.sh | bash"
    show "tru" "tru" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/toon_rust/master/install.sh | bash"
    show "rano" "rano" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/rano/main/install.sh | bash"
    show "giil" "giil" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/giil/main/install.sh | bash"
    show "brenner" "brenner" "curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/brenner_bot/main/install.sh | bash"
}

run_update() {
    print_header
    echo -e "${BOLD}Updating Flywheel Tools...${NC}"
    echo ""

    [[ "$PKG_MGR" == "brew" ]] && {
        echo "Updating Homebrew packages..."
        brew update >/dev/null 2>&1
        brew upgrade ntm bv cass cm ubs pt xf tru ru caam zoxide atuin 2>/dev/null || true
    }

    has go && {
        echo "Updating Go packages..."
        go install github.com/Dicklesworthstone/slb/cmd/slb@latest 2>/dev/null || true
    }

    echo "Updating DCG..."
    curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/destructive_command_guard/main/install.sh" 2>/dev/null | bash -s -- --easy-mode 2>/dev/null || true

    has npm && {
        echo "Updating npm packages..."
        npm update -g @anthropic-ai/claude-code 2>/dev/null || true
    }

    echo ""
    echo -e "${GREEN}Update complete!${NC}"
}

run_uninstall() {
    print_header
    echo -e "${BOLD}${RED}Uninstall Agentic Coding Flywheel${NC}"
    echo ""
    echo -e "${YELLOW}This will remove:${NC}"
    echo "  - All 33 ACFS tools (ntm, br, bv, cass, cm, dcg, etc.)"
    echo "  - AI agents (claude, codex, gemini)"
    echo "  - Shell enhancements (zoxide, atuin)"
    echo "  - Shell config additions"
    echo "  - Flywheel script itself"
    echo ""
    echo -e "${CYAN}Kept:${NC} go, cargo, bun, tmux, git (commonly used by other tools)"
    echo ""

    read -p "Continue? [y/N] " -n 1 -r
    echo ""
    [[ ! $REPLY =~ ^[Yy]$ ]] && { echo "Cancelled."; return; }
    echo ""

    remove_bin() {
        local name=$1
        local paths=(
            "$HOME/.local/bin/$name"
            "$HOME/go/bin/$name"
            "$HOME/.cargo/bin/$name"
        )
        for p in "${paths[@]}"; do
            [[ -f "$p" || -L "$p" ]] && { rm -f "$p"; echo -e "  ${GREEN}✓${NC} Removed $p"; }
        done
    }

    # ACFS tools
    echo -e "${BOLD}Removing ACFS Tools:${NC}"

    # Homebrew packages
    if [[ "$PKG_MGR" == "brew" ]]; then
        for pkg in ntm bv cass ubs pt zoxide atuin fzf jq; do
            brew list "$pkg" &>/dev/null && { brew uninstall "$pkg" 2>/dev/null; echo -e "  ${GREEN}✓${NC} Uninstalled $pkg (brew)"; }
        done
        # Tap packages
        for pkg in dicklesworthstone/tap/bv dicklesworthstone/tap/cass dicklesworthstone/tap/ubs; do
            brew list "$pkg" &>/dev/null && brew uninstall "$pkg" 2>/dev/null
        done
    fi

    # Binary tools
    for tool in br cm dcg ms s2p ru apr caam xf csctf tru rano giil brenner slb pt ntm bv cass ubs am; do
        remove_bin "$tool"
    done

    # npm/bun global packages
    echo ""
    echo -e "${BOLD}Removing AI Agents:${NC}"
    npm list -g @anthropic-ai/claude-code &>/dev/null && { npm uninstall -g @anthropic-ai/claude-code 2>/dev/null; echo -e "  ${GREEN}✓${NC} Uninstalled claude"; }
    npm list -g @openai/codex &>/dev/null && { npm uninstall -g @openai/codex 2>/dev/null; echo -e "  ${GREEN}✓${NC} Uninstalled codex"; }
    npm list -g @google/gemini-cli &>/dev/null && { npm uninstall -g @google/gemini-cli 2>/dev/null; echo -e "  ${GREEN}✓${NC} Uninstalled gemini"; }

    # MCP Agent Mail
    echo ""
    echo -e "${BOLD}Removing MCP Agent Mail:${NC}"
    pgrep -f "mcp-agent-mail" &>/dev/null && { pkill -f "mcp-agent-mail" 2>/dev/null; echo -e "  ${GREEN}✓${NC} Stopped MCP Agent Mail"; }
    [[ -d "$HOME/.mcp-agent-mail" ]] && { rm -rf "$HOME/.mcp-agent-mail"; echo -e "  ${GREEN}✓${NC} Removed ~/.mcp-agent-mail"; }

    # Shell config cleanup
    echo ""
    echo -e "${BOLD}Cleaning shell config:${NC}"
    local rc="$HOME/.zshrc"
    [[ "$SHELL" == */bash ]] && rc="$HOME/.bashrc"
    if [[ -f "$rc" ]]; then
        cp "$rc" "$rc.flywheel-backup"
        # Remove flywheel-related lines
        sed -i.bak '/ntm shell/d; /zoxide init/d; /# Flywheel/d' "$rc" 2>/dev/null || \
        sed -i '' '/ntm shell/d; /zoxide init/d; /# Flywheel/d' "$rc"
        rm -f "$rc.bak"
        echo -e "  ${GREEN}✓${NC} Removed shell integrations (ntm, zoxide)"
        echo -e "  ${CYAN}Backup saved to $rc.flywheel-backup${NC}"
    fi

    # Remove flywheel itself
    echo ""
    echo -e "${BOLD}Removing Flywheel:${NC}"

    # Remove symlink
    [[ -L "$HOME/.local/bin/flywheel" ]] && { rm -f "$HOME/.local/bin/flywheel"; echo -e "  ${GREEN}✓${NC} Removed ~/.local/bin/flywheel symlink"; }
    [[ -f "$HOME/.local/bin/flywheel" ]] && { rm -f "$HOME/.local/bin/flywheel"; echo -e "  ${GREEN}✓${NC} Removed ~/.local/bin/flywheel"; }

    # Remove source directory (standard location)
    if [[ -d "$HOME/.local/share/flywheel" ]]; then
        rm -rf "$HOME/.local/share/flywheel"
        echo -e "  ${GREEN}✓${NC} Removed ~/.local/share/flywheel"
    fi

    # Check for other locations
    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    if [[ "$script_dir" != "$HOME/.local/share/flywheel" && "$script_dir" != "$HOME/.local/bin" ]]; then
        echo ""
        echo -e "  ${YELLOW}Note:${NC} Flywheel source at $script_dir was not removed."
        echo -e "  Remove manually if desired: ${CYAN}rm -rf $script_dir${NC}"
    fi

    echo ""
    echo -e "${GREEN}${BOLD}Uninstall complete!${NC}"
    echo ""
    echo "Restart your terminal or run: source $rc"
}

run_init() {
    local project_name=${1:-$(basename "$PWD")}

    echo -e "${BOLD}${CYAN}Initializing Flywheel Project: $project_name${NC}"
    echo ""

    # Check if already initialized
    if [[ -d ".beads" ]]; then
        echo -e "${YELLOW}Project already initialized (.beads/ exists)${NC}"
    else
        # Initialize beads
        if has br; then
            echo -e "${CYAN}Initializing task tracking...${NC}"
            br init
            echo -e "${GREEN}✓${NC} Task tracking initialized"
        else
            echo -e "${RED}✗${NC} br not installed. Run: flywheel install"
        fi
    fi

    # Create AGENTS.md if it doesn't exist
    if [[ -f "AGENTS.md" ]]; then
        echo -e "${YELLOW}AGENTS.md already exists${NC}"
    else
        echo -e "${CYAN}Creating AGENTS.md...${NC}"
        cat > AGENTS.md << EOF
# $project_name

## Overview
<!-- Brief description of what this project does -->

## Tech Stack
<!-- List your technologies -->
- Language:
- Framework:
- Database:

## Directory Structure
<!-- Key directories and their purposes -->
- \`src/\` - Main source code
- \`tests/\` - Test files

## Conventions
<!-- Coding standards and patterns to follow -->
- Follow existing patterns in codebase
- Write tests for new features

## Getting Started
\`\`\`bash
# Install dependencies
# ...

# Run the project
# ...
\`\`\`

## Current Focus
<!-- What we're actively working on -->

## Notes for AI Agents
<!-- Special instructions or context for AI assistants -->
- Check \`br ready\` for available tasks
- Use \`cm context "task"\` for memory context
- Run \`ubs scan .\` before committing
EOF
        echo -e "${GREEN}✓${NC} Created AGENTS.md"
    fi

    # Create .claude/settings.local.json for project-specific Claude settings
    if [[ ! -d ".claude" ]]; then
        mkdir -p .claude
        echo -e "${GREEN}✓${NC} Created .claude/ directory"
    fi

    echo ""
    echo -e "${GREEN}${BOLD}Project initialized!${NC}"
    echo ""
    echo -e "Next steps:"
    echo -e "  1. Edit ${CYAN}AGENTS.md${NC} with project details"
    echo -e "  2. Create tasks: ${CYAN}br create \"First task\" --type feature${NC}"
    echo -e "  3. Spawn agents: ${CYAN}ntm spawn $project_name --cc=2${NC}"
    echo -e "  4. Get context:  ${CYAN}cm context \"what to work on\" --json${NC}"
    echo -e "  5. Send to agents: ${CYAN}ntm send $project_name --cc \"Start working\"${NC}"
    echo ""
}

fix_mail_server() {
    # Helper function to fix MCP Agent Mail issues
    # Check multiple possible locations
    local mail_dir=""
    if [[ -d "$HOME/mcp_agent_mail" ]]; then
        mail_dir="$HOME/mcp_agent_mail"
    elif [[ -d "$HOME/Developer/mcp_agent_mail" ]]; then
        mail_dir="$HOME/Developer/mcp_agent_mail"
    elif [[ -d "$HOME/.mcp-agent-mail" ]]; then
        mail_dir="$HOME/.mcp-agent-mail"
    fi

    # Exit early if not found
    if [[ -z "$mail_dir" ]]; then
        return 0  # Not installed, nothing to fix
    fi
    local mail_db="$mail_dir/storage.sqlite3"
    local mail_wal="$mail_dir/storage.sqlite3-wal"
    local mail_shm="$mail_dir/storage.sqlite3-shm"
    local mail_fixed=0

    local issues_found=false
    local needs_restart=false

    # Check for orphaned WAL/SHM files
    if [[ ! -f "$mail_db" ]] && { [[ -f "$mail_wal" ]] || [[ -f "$mail_shm" ]]; }; then
        issues_found=true
    fi

    # Check for corrupted database
    if [[ -f "$mail_db" ]]; then
        if ! sqlite3 "$mail_db" "SELECT 1 FROM sqlite_master LIMIT 1;" &>/dev/null; then
            issues_found=true
        fi
    fi

    # Check if server is running (HTTP check is more reliable, especially on WSL)
    local mail_pids=$(pgrep -f "mcp_agent_mail" 2>/dev/null)
    local http_ok=false
    if curl -s --connect-timeout 2 -o /dev/null "http://localhost:8765/api/health" 2>/dev/null; then
        http_ok=true
    fi
    if [[ -z "$mail_pids" ]] && [[ "$http_ok" == false ]]; then
        needs_restart=true
    fi

    if [[ "$issues_found" == false ]] && [[ "$needs_restart" == false ]]; then
        return 0  # No issues
    fi

    echo -e "${BOLD}MCP Agent Mail:${NC}"

    # Kill any existing processes if there are issues
    if [[ -n "$mail_pids" ]] && [[ "$issues_found" == true ]]; then
        for pid in $mail_pids; do
            kill "$pid" 2>/dev/null && echo -e "  ${GREEN}✓${NC} Killed stale process (PID $pid)"
            mail_fixed=$((mail_fixed + 1))
        done
        sleep 2
        mail_pids=""  # Clear so we restart
    fi

    # Clean up database files if corrupted or orphaned
    if [[ "$issues_found" == true ]]; then
        rm -f "$mail_db" "$mail_wal" "$mail_shm" 2>/dev/null
        echo -e "  ${GREEN}✓${NC} Cleaned up corrupted/orphaned database files"
        mail_fixed=$((mail_fixed + 1))
    fi

    # Start server if not running
    if [[ "$needs_restart" == true ]] || [[ "$issues_found" == true ]]; then
        local orig_dir="$PWD"
        cd "$mail_dir" || return $mail_fixed
        nohup uv run python -m mcp_agent_mail.cli serve-http &>/dev/null &
        cd "$orig_dir" || true
        sleep 3
        # Verify with HTTP check (more reliable than pgrep on WSL)
        if curl -s --connect-timeout 2 -o /dev/null "http://localhost:8765/api/health" 2>/dev/null; then
            echo -e "  ${GREEN}✓${NC} Started server (HTTP health check passed)"
            mail_fixed=$((mail_fixed + 1))
        else
            echo -e "  ${RED}✗${NC} Failed to start server"
        fi
    fi

    if [[ $mail_fixed -gt 0 ]]; then
        echo -e "  ${YELLOW}Note:${NC} Restart Claude Code to re-establish MCP connection"
    fi
    echo ""

    return $mail_fixed
}

run_fix() {
    print_header
    echo -e "${BOLD}Auto-fixing all issues...${NC}"
    echo ""

    local rc="$HOME/.zshrc"
    local shell_name="zsh"
    [[ "$SHELL" == */bash ]] && { rc="$HOME/.bashrc"; shell_name="bash"; }

    local fixed=0

    # === PATH fixes ===
    echo -e "${BOLD}PATH Configuration:${NC}"
    local path_fixed=0
    if ! echo "$PATH" | grep -q "$HOME/.local/bin"; then
        echo 'export PATH="$HOME/.local/bin:$PATH"' >> "$rc"
        echo -e "  ${GREEN}✓${NC} Added ~/.local/bin to PATH"
        path_fixed=$((path_fixed + 1))
    fi
    if ! echo "$PATH" | grep -q "$HOME/go/bin"; then
        echo 'export PATH="$HOME/go/bin:$PATH"' >> "$rc"
        echo -e "  ${GREEN}✓${NC} Added ~/go/bin to PATH"
        path_fixed=$((path_fixed + 1))
    fi
    if ! echo "$PATH" | grep -q "$HOME/.cargo/bin"; then
        echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> "$rc"
        echo -e "  ${GREEN}✓${NC} Added ~/.cargo/bin to PATH"
        path_fixed=$((path_fixed + 1))
    fi
    if [[ $path_fixed -eq 0 ]]; then
        echo -e "  ${GREEN}✓${NC} All paths configured correctly"
    fi
    fixed=$((fixed + path_fixed))
    echo ""

    # === Shell integration fixes ===
    echo -e "${BOLD}Shell Integration:${NC}"
    local shell_fixed=0
    if has ntm && ! grep -q 'ntm shell' "$rc" 2>/dev/null; then
        echo "eval \"\$(ntm shell $shell_name)\"" >> "$rc"
        echo -e "  ${GREEN}✓${NC} Added NTM shell integration"
        shell_fixed=$((shell_fixed + 1))
    fi
    if has zoxide && ! grep -q 'zoxide init' "$rc" 2>/dev/null; then
        echo "eval \"\$(zoxide init $shell_name)\"" >> "$rc"
        echo -e "  ${GREEN}✓${NC} Added zoxide integration"
        shell_fixed=$((shell_fixed + 1))
    fi
    if has atuin && ! grep -q 'atuin init' "$rc" 2>/dev/null; then
        echo "eval \"\$(atuin init $shell_name)\"" >> "$rc"
        echo -e "  ${GREEN}✓${NC} Added atuin integration"
        shell_fixed=$((shell_fixed + 1))
    fi
    if [[ $shell_fixed -eq 0 ]]; then
        echo -e "  ${GREEN}✓${NC} All shell integrations configured"
    fi
    fixed=$((fixed + shell_fixed))
    echo ""

    # === MCP Agent Mail fixes ===
    fix_mail_server
    local mail_fixes=$?
    fixed=$((fixed + mail_fixes))

    # === Summary ===
    echo -e "${BOLD}Summary:${NC}"
    if [[ $fixed -gt 0 ]]; then
        echo -e "${GREEN}Fixed $fixed issue(s).${NC}"
        [[ $path_fixed -gt 0 || $shell_fixed -gt 0 ]] && echo -e "Run: ${CYAN}source $rc${NC} to apply shell changes"
    else
        echo -e "${GREEN}No issues to fix - everything looks good!${NC}"
    fi
    echo ""
}

run_upgrade() {
    print_header
    echo -e "${BOLD}Upgrading Flywheel...${NC}"
    echo ""

    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    if [[ -d "$script_dir/.git" ]]; then
        echo "Pulling latest changes..."
        cd "$script_dir" && git pull
        echo ""
        echo -e "${GREEN}✓${NC} Flywheel upgraded!"
        echo -e "Run ${CYAN}flywheel doctor${NC} to verify."
    elif [[ -d "$HOME/.local/share/flywheel/.git" ]]; then
        echo "Pulling latest changes..."
        cd "$HOME/.local/share/flywheel" && git pull
        echo ""
        echo -e "${GREEN}✓${NC} Flywheel upgraded!"
    else
        echo -e "${RED}✗${NC} Could not find flywheel git repository."
        echo -e "Re-install with: ${CYAN}curl -fsSL https://raw.githubusercontent.com/Acelogic/agentic-coding-flywheel-setup-simplified/main/install.sh | bash${NC}"
    fi
}

run_spawn() {
    local name="${1:-$(basename "$PWD")}"
    local agents="${2:-2}"

    if ! has ntm; then
        echo -e "${RED}✗${NC} NTM not installed. Run: flywheel install"
        return 1
    fi

    echo -e "${BOLD}Spawning $agents Claude agent(s) for: $name${NC}"
    ntm spawn "$name" --cc="$agents"
}

run_sessions() {
    print_header
    echo -e "${BOLD}Active Sessions:${NC}"
    echo ""

    local sessions=$(tmux list-sessions 2>/dev/null)
    if [[ -n "$sessions" ]]; then
        echo "$sessions"
        echo ""
        echo -e "Commands:"
        echo -e "  Attach:  ${CYAN}tmux attach -t <name>${NC}"
        echo -e "  Kill:    ${CYAN}tmux kill-session -t <name>${NC}"
        echo -e "  Kill all: ${CYAN}tmux kill-server${NC}"
    else
        echo -e "${YELLOW}No active sessions${NC}"
    fi
    echo ""

    # Show MCP Agent Mail status
    if curl -s http://127.0.0.1:8765/health &>/dev/null; then
        echo -e "${GREEN}✓${NC} MCP Agent Mail running on :8765"
    fi
}

run_new() {
    local name="$1"

    if [[ -z "$name" ]]; then
        echo -e "${RED}Usage: flywheel new <project-name>${NC}"
        return 1
    fi

    if [[ -d "$name" ]]; then
        echo -e "${RED}Directory '$name' already exists${NC}"
        return 1
    fi

    echo -e "${BOLD}Creating new project: $name${NC}"
    mkdir -p "$name"
    cd "$name" || return 1
    git init --quiet

    # Run init in the new directory
    run_init "$name"

    echo ""
    echo -e "Created at: ${CYAN}$(pwd)${NC}"
}

run_auth() {
    print_header
    echo -e "${BOLD}Authentication Status:${NC}"
    echo ""

    # Claude
    echo -e "${BOLD}Claude:${NC}"
    if [[ -f "$HOME/.claude/.credentials.json" ]] || [[ -f "$HOME/.config/claude/credentials.json" ]]; then
        echo -e "  ${GREEN}✓${NC} Authenticated"
    else
        echo -e "  ${YELLOW}○${NC} Not authenticated"
        echo -e "  Run: ${CYAN}claude${NC} (follow prompts to login)"
    fi
    echo ""

    # Codex
    echo -e "${BOLD}Codex:${NC}"
    if [[ -f "$HOME/.codex/auth.json" ]]; then
        echo -e "  ${GREEN}✓${NC} Authenticated (config file)"
    elif [[ -n "$OPENAI_API_KEY" ]]; then
        echo -e "  ${GREEN}✓${NC} Authenticated (OPENAI_API_KEY set)"
    else
        echo -e "  ${YELLOW}○${NC} Not authenticated"
        echo -e "  Run: ${CYAN}codex${NC} or set ${CYAN}OPENAI_API_KEY${NC}"
    fi
    echo ""

    # Gemini
    echo -e "${BOLD}Gemini:${NC}"
    if [[ -f "$HOME/.config/gemini/credentials.json" ]]; then
        echo -e "  ${GREEN}✓${NC} Authenticated (config file)"
    elif [[ -n "$GOOGLE_API_KEY" ]] || [[ -n "$GEMINI_API_KEY" ]]; then
        echo -e "  ${GREEN}✓${NC} Authenticated (API key set)"
    else
        echo -e "  ${YELLOW}○${NC} Not authenticated"
        echo -e "  Run: ${CYAN}gemini${NC} or set ${CYAN}GEMINI_API_KEY${NC}"
    fi
    echo ""
}

run_logs() {
    print_header
    echo -e "${BOLD}Recent Session Logs:${NC}"
    echo ""

    # Check for CASS logs
    if has cass; then
        echo -e "${BOLD}Recent CASS sessions:${NC}"
        cass search "" --limit 5 2>/dev/null || echo "  No sessions found"
        echo ""
    fi

    # Check Claude logs
    local claude_log="$HOME/.claude/logs"
    if [[ -d "$claude_log" ]]; then
        echo -e "${BOLD}Recent Claude logs:${NC}"
        ls -lt "$claude_log"/*.log 2>/dev/null | head -5 | while read -r line; do
            echo "  $line"
        done
        echo ""
        echo -e "View latest: ${CYAN}tail -f $claude_log/$(ls -t "$claude_log" 2>/dev/null | head -1)${NC}"
    fi

    # Check tmux logs if any
    echo ""
    echo -e "${BOLD}Active tmux sessions:${NC}"
    tmux list-sessions 2>/dev/null || echo "  No active sessions"
}

run_clean() {
    print_header
    echo -e "${BOLD}Cleaning up...${NC}"
    echo ""

    local cleaned=0

    # Kill stale tmux sessions (older than 7 days with no activity)
    echo -e "${BOLD}Stale sessions:${NC}"
    local stale=$(tmux list-sessions 2>/dev/null | grep -v attached)
    if [[ -n "$stale" ]]; then
        echo "$stale"
        read -p "Kill detached sessions? [y/N] " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            tmux list-sessions -F '#{session_name}' 2>/dev/null | while read -r sess; do
                tmux has-session -t "$sess" 2>/dev/null && \
                ! tmux list-clients -t "$sess" 2>/dev/null | grep -q . && \
                tmux kill-session -t "$sess" && \
                echo -e "  ${GREEN}✓${NC} Killed $sess"
            done
            cleaned=$((cleaned + 1))
        fi
    else
        echo -e "  ${GREEN}✓${NC} No stale sessions"
    fi
    echo ""

    # Clean npm cache
    echo -e "${BOLD}Package caches:${NC}"
    if has npm; then
        local npm_cache=$(npm cache ls 2>/dev/null | wc -l | tr -d ' ')
        if [[ "$npm_cache" -gt 100 ]]; then
            echo -e "  npm cache: $npm_cache entries"
            read -p "  Clean npm cache? [y/N] " -n 1 -r
            echo ""
            [[ $REPLY =~ ^[Yy]$ ]] && { npm cache clean --force 2>/dev/null; echo -e "  ${GREEN}✓${NC} Cleaned npm cache"; cleaned=$((cleaned + 1)); }
        else
            echo -e "  ${GREEN}✓${NC} npm cache is small"
        fi
    fi

    # Clean bun cache
    if has bun && [[ -d "$HOME/.bun/install/cache" ]]; then
        local bun_size=$(du -sh "$HOME/.bun/install/cache" 2>/dev/null | cut -f1)
        echo -e "  bun cache: $bun_size"
    fi

    echo ""
    echo -e "${GREEN}Cleanup complete!${NC}"
}

run_start() {
    local project_name=$(basename "$PWD")
    local flywheel_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    local guide_path="$flywheel_dir/NTM_WORKFLOW_GUIDE.md"

    # Run quick health check first (stderr so it doesn't pollute the context output)
    local health_issues=0

    # Check MCP Agent Mail (check multiple possible locations)
    local mail_dir=""
    if [[ -d "$HOME/mcp_agent_mail" ]]; then
        mail_dir="$HOME/mcp_agent_mail"
    elif [[ -d "$HOME/Developer/mcp_agent_mail" ]]; then
        mail_dir="$HOME/Developer/mcp_agent_mail"
    elif [[ -d "$HOME/.mcp-agent-mail" ]]; then
        mail_dir="$HOME/.mcp-agent-mail"
    fi
    local mail_db="$mail_dir/storage.sqlite3"
    local mail_wal="$mail_dir/storage.sqlite3-wal"
    local mail_shm="$mail_dir/storage.sqlite3-shm"

    if [[ -n "$mail_dir" ]] && [[ -d "$mail_dir" ]]; then
        # Check for orphaned files
        if [[ ! -f "$mail_db" ]] && { [[ -f "$mail_wal" ]] || [[ -f "$mail_shm" ]]; }; then
            echo "⚠️  MCP Agent Mail has orphaned database files. Run: flywheel fix" >&2
            health_issues=$((health_issues + 1))
        elif [[ -f "$mail_db" ]] && ! sqlite3 "$mail_db" "SELECT 1 FROM sqlite_master LIMIT 1;" &>/dev/null; then
            echo "⚠️  MCP Agent Mail database is corrupted. Run: flywheel fix" >&2
            health_issues=$((health_issues + 1))
        elif ! pgrep -f "mcp_agent_mail" &>/dev/null; then
            echo "⚠️  MCP Agent Mail not running. Starting..." >&2
            cd "$mail_dir" && nohup uv run python -m mcp_agent_mail.cli serve-http &>/dev/null &
            sleep 2
        fi
    fi

    # Check task tracking
    if [[ ! -d ".beads" ]]; then
        echo "⚠️  Task tracking not initialized. Run: br init" >&2
    fi

    [[ $health_issues -gt 0 ]] && echo "" >&2

    # Detect project info
    local tech_stack=""
    [[ -f "package.json" ]] && tech_stack="Node.js/JavaScript"
    [[ -f "Cargo.toml" ]] && tech_stack="Rust"
    [[ -f "go.mod" ]] && tech_stack="Go"
    [[ -f "pyproject.toml" || -f "requirements.txt" ]] && tech_stack="Python"
    [[ -f "Gemfile" ]] && tech_stack="Ruby"

    # Check for frameworks
    [[ -f "package.json" ]] && {
        grep -q '"next"' package.json 2>/dev/null && tech_stack="Next.js"
        grep -q '"react"' package.json 2>/dev/null && [[ "$tech_stack" != "Next.js" ]] && tech_stack="React"
        grep -q '"vue"' package.json 2>/dev/null && tech_stack="Vue.js"
        grep -q '"svelte"' package.json 2>/dev/null && tech_stack="Svelte"
        grep -q '"express"' package.json 2>/dev/null && tech_stack="${tech_stack:+$tech_stack + }Express"
    }

    # Detect available AI agents
    local available_agents=""
    local agent_flags=""
    has claude && { available_agents="${available_agents}Claude Code (--cc), "; agent_flags="${agent_flags}--cc "; }
    has codex && { available_agents="${available_agents}Codex (--cod), "; agent_flags="${agent_flags}--cod "; }
    has gemini && { available_agents="${available_agents}Gemini (--gmi), "; agent_flags="${agent_flags}--gmi "; }
    available_agents="${available_agents%, }"  # Remove trailing comma

    # Output context for agent injection
    cat << 'WORKFLOW_HEADER'
# Agentic Coding Flywheel - Admin Agent Context

⚠️ **CRITICAL: You are the ADMIN AGENT**

You are the orchestrator/coordinator. **DO NOT write code or make changes directly.**

Your role is to:
1. **Ask the user** what agents they want and how many
2. **Spawn worker agents** using NTM to do the actual work
3. **Create and manage tasks** using `br`
4. **Monitor progress** and coordinate between workers
5. **Review results** from worker agents

The actual coding work should be done by worker agents you spawn via NTM.

---

WORKFLOW_HEADER

    # Output available agents section
    echo "## Available AI Agents"
    echo ""
    if [[ -n "$available_agents" ]]; then
        echo "**Installed:** $available_agents"
        echo ""
        echo "**Spawn examples** (use \`--no-user\` since you're the admin in a separate session):"
        echo '```bash'
        has claude && echo "ntm spawn $project_name --cc=2 --no-user      # 2 Claude workers"
        has codex && echo "ntm spawn $project_name --cod=2 --no-user     # 2 Codex workers"
        has gemini && echo "ntm spawn $project_name --gmi=1 --no-user     # 1 Gemini worker"
        echo ""
        echo "# Mix agents:"
        has claude && has gemini && echo "ntm spawn $project_name --cc=2 --gmi=1 --no-user   # 2 Claude + 1 Gemini"
        has claude && has codex && echo "ntm spawn $project_name --cc=1 --cod=2 --no-user   # 1 Claude + 2 Codex"
        echo '```'
    else
        echo "**No AI agents installed!** Run: flywheel install"
    fi
    echo ""
    echo "⚠️ **IMPORTANT:** Before spawning, ASK the user:"
    echo "- Which agent type(s) do they want? (Claude, Codex, Gemini)"
    echo "- How many workers should be spawned?"
    echo ""

    cat << 'WORKFLOW_COMMANDS'
---

## Your Admin Commands

```bash
# Task Management (create tasks for workers)
br ready                    # See available tasks
br list                     # List all tasks
br create "desc" --type T   # Create task (T: feature|bug|task|refactor)
br update ID --status S     # Update status (S: todo|in_progress|done)

# Spawn Worker Agents (THIS IS HOW WORK GETS DONE)
ntm spawn PROJECT --cc=N    # Spawn N Claude worker agents
ntm spawn PROJECT --cod=N   # Spawn N Codex worker agents
ntm spawn PROJECT --gmi=N   # Spawn N Gemini worker agents
ntm send PROJECT --pane=N "msg"  # Send to specific worker
ntm status PROJECT          # Check worker status

# Memory & Context (share with workers)
cm context "task" --json    # Get relevant memory/patterns

# Coordination
# Workers auto-discover MCP Agent Mail for file reservations
```

---

## Admin Workflow

### Step 0: Ask User About Workers
Before spawning, ask the user:
- "Which AI agents should I use? (Claude Code, Codex, Gemini)"
- "How many workers do you want?"

### Step 1: Setup Tasks
```bash
br ready                    # Check existing tasks
br create "Task 1" --type feature
br create "Task 2" --type feature
```

### Step 2: Spawn Workers (Based on User Choice)
```bash
# Use --no-user since you (admin) are in a separate session
ntm spawn myproject --cc=2 --no-user  # If user wants 2 Claude workers
```

### Step 3: Assign Work to Workers
```bash
ntm send myproject --pane=1 "Read ARCHITECTURE.md, check br ready, claim task bd-xxx and implement it"
ntm send myproject --pane=2 "Read ARCHITECTURE.md, check br ready, claim task bd-yyy and implement it"
```

### Step 4: Monitor & Coordinate
```bash
ntm status myproject        # Check progress
br list                     # See task status updates
```

### Step 5: Review Results
```bash
# Check what workers produced
git status
git diff
ubs scan .                  # Scan for bugs before committing
```

---

## Why This Matters

- **You (admin)** = orchestration, planning, task management
- **Workers (via NTM)** = actual coding, file changes, implementation
- Workers use MCP Agent Mail to coordinate file access
- This prevents conflicts and enables parallel work

---

WORKFLOW_COMMANDS

    # Project-specific context
    echo "## Current Project: $project_name"
    echo ""

    if [[ -n "$tech_stack" ]]; then
        echo "**Tech Stack:** $tech_stack"
        echo ""
    fi

    # Show AGENTS.md if exists
    if [[ -f "AGENTS.md" ]]; then
        echo "### Project Instructions (from AGENTS.md)"
        echo ""
        echo '```markdown'
        head -50 AGENTS.md
        [[ $(wc -l < AGENTS.md) -gt 50 ]] && echo "... (truncated, see full AGENTS.md)"
        echo '```'
        echo ""
    fi

    # Show current tasks
    if [[ -d ".beads" ]] && has br; then
        local ready_tasks=$(br ready 2>/dev/null)
        local task_count=$(br list 2>/dev/null | wc -l | tr -d ' ')

        if [[ -n "$ready_tasks" ]]; then
            echo "### Ready Tasks"
            echo ""
            echo '```'
            echo "$ready_tasks" | head -10
            echo '```'
            echo ""
        fi

        if [[ "$task_count" -gt 0 ]]; then
            echo "**Total tasks:** $task_count"
            echo ""
        fi
    else
        echo "### No Task Tracking"
        echo ""
        echo "Run \`br init\` or \`flywheel init\` to enable task tracking."
        echo ""
    fi

    # Instructions for the agent
    cat << 'WORKFLOW_FOOTER'
---

## Your Next Steps (As Admin Agent)

1. **Check/create tasks:** Run `br ready` and `br create` to set up work
2. **Spawn workers:** Run `ntm spawn PROJECT --cc=N` to create worker agents
3. **Assign tasks:** Run `ntm send PROJECT --pane=N "instructions"` to assign work
4. **Monitor:** Run `ntm status PROJECT` to check progress
5. **Review:** When workers finish, review with `git diff` and `ubs scan .`

**⚠️ Remember: You are the ADMIN - do NOT code directly!**

- Spawn worker agents with `ntm spawn` for all implementation work
- Workers will use MCP Agent Mail to coordinate file access
- Your job is orchestration: create tasks, spawn workers, monitor, review

Ready to orchestrate. What tasks should we set up for the workers?
WORKFLOW_FOOTER
}

run_env() {
    print_header
    echo -e "${BOLD}Environment Info:${NC}"
    echo ""

    echo -e "${BOLD}System:${NC}"
    echo "  OS: $(uname -s) $(uname -r)"
    echo "  Arch: $(uname -m)"
    echo "  Shell: $SHELL"
    echo ""

    echo -e "${BOLD}Flywheel:${NC}"
    echo "  Version: $VERSION"
    echo "  Location: $(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    echo "  Platform: $PLATFORM"
    echo "  Package Manager: $PKG_MGR"
    echo ""

    echo -e "${BOLD}PATH directories:${NC}"
    echo "$PATH" | tr ':' '\n' | head -10 | while read -r p; do
        echo "  $p"
    done
    echo ""

    echo -e "${BOLD}Key versions:${NC}"
    echo "  node: $(node --version 2>/dev/null || echo 'not installed')"
    echo "  bun: $(bun --version 2>/dev/null || echo 'not installed')"
    echo "  go: $(go version 2>/dev/null | awk '{print $3}' || echo 'not installed')"
    echo "  rust: $(rustc --version 2>/dev/null | awk '{print $2}' || echo 'not installed')"
    echo "  python: $(python3 --version 2>/dev/null | awk '{print $2}' || echo 'not installed')"
    echo ""

    echo -e "${BOLD}Memory:${NC}"
    if [[ "$PLATFORM" == "macos" ]]; then
        local mem_total=$(sysctl -n hw.memsize 2>/dev/null)
        local mem_gb=$((mem_total / 1073741824))
        echo "  Total: ${mem_gb}GB"
        echo "  Recommended agents: $((mem_gb / 2))"
    else
        local mem_total=$(grep MemTotal /proc/meminfo 2>/dev/null | awk '{print $2}')
        local mem_gb=$((mem_total / 1048576))
        echo "  Total: ${mem_gb}GB"
        echo "  Recommended agents: $((mem_gb / 2))"
    fi
    echo ""
}

# Main
detect_platform

# Smart default: start if project initialized, doctor otherwise
default_cmd="doctor"
[[ -d ".beads" || -f "AGENTS.md" ]] && default_cmd="start"

case "${1:-$default_cmd}" in
    init)      run_init "$2" ;;
    install)   run_install ;;
    doctor)    run_doctor ;;
    update)    run_update ;;
    missing)   show_missing ;;
    uninstall) run_uninstall ;;
    fix)       run_fix ;;
    upgrade)   run_upgrade ;;
    spawn)     run_spawn "$2" "$3" ;;
    sessions)  run_sessions ;;
    new)       run_new "$2" ;;
    auth)      run_auth ;;
    logs)      run_logs ;;
    clean)     run_clean ;;
    env)       run_env ;;
    start)     run_start ;;
    version)   echo "flywheel $VERSION" ;;
    help|--help|-h)
        print_header
        echo -e "Usage: ${CYAN}flywheel${NC} ${GREEN}<command>${NC} [options]"
        echo ""
        echo -e "${BOLD}${BLUE}━━━ Setup ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "  ${GREEN}install${NC}      Install all 33 ACFS tools"
        echo -e "  ${GREEN}doctor${NC}       Health check: tools, PATH, auth, versions"
        echo -e "  ${GREEN}fix${NC}          Auto-fix all issues (PATH, shell, services)"
        echo -e "  ${GREEN}update${NC}       Update all installed tools"
        echo -e "  ${GREEN}upgrade${NC}      Update flywheel itself (git pull)"
        echo -e "  ${GREEN}uninstall${NC}    Remove everything and clean up"
        echo ""
        echo -e "${BOLD}${BLUE}━━━ Projects ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "  ${GREEN}new${NC} ${CYAN}<name>${NC}    Create new project: mkdir + git init + flywheel init"
        echo -e "  ${GREEN}init${NC}         Initialize current dir: .beads/ + AGENTS.md + .claude/"
        echo -e "  ${GREEN}start${NC}        Output workflow context for AI agent ${YELLOW}(default if initialized)${NC}"
        echo -e "  ${GREEN}spawn${NC} ${CYAN}<name>${NC} ${YELLOW}[n]${NC}  Spawn n Claude agents (default: 2)"
        echo ""
        echo -e "${BOLD}${BLUE}━━━ Info ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "  ${GREEN}sessions${NC}     List active tmux sessions"
        echo -e "  ${GREEN}auth${NC}         Check AI agent authentication status"
        echo -e "  ${GREEN}logs${NC}         View recent CASS sessions and Claude logs"
        echo -e "  ${GREEN}env${NC}          Show system info, versions, RAM, paths"
        echo -e "  ${GREEN}missing${NC}      Show manual install commands for missing tools"
        echo ""
        echo -e "${BOLD}${BLUE}━━━ Maintenance ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "  ${GREEN}clean${NC}        Kill stale sessions, clean package caches"
        echo -e "  ${GREEN}version${NC}      Show flywheel version"
        echo ""
        echo -e "${BOLD}${BLUE}━━━ Quick Start ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "  ${CYAN}flywheel install${NC}           # First time: install everything"
        echo -e "  ${CYAN}flywheel doctor${NC}            # Check what's working"
        echo -e "  ${CYAN}flywheel fix${NC}               # Fix any issues"
        echo ""
        echo -e "${BOLD}${BLUE}━━━ New Project ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "  ${CYAN}flywheel new my-app${NC}        # Create project"
        echo -e "  ${CYAN}cd my-app${NC}"
        echo -e "  ${CYAN}flywheel start${NC}             # Inject workflow context into agent"
        echo -e "  ${CYAN}br create \"Task\" --type feature${NC}"
        echo ""
        echo -e "${BOLD}${BLUE}━━━ Agent Workflow ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "  Tell an agent: ${YELLOW}\"run flywheel and proceed with the plan\"${NC}"
        echo -e "  In initialized projects, \`flywheel\` = \`flywheel start\`"
        echo ""
        echo -e "${BOLD}Links:${NC}"
        echo -e "  Tools:  ${CYAN}https://agent-flywheel.com/tldr${NC}"
        echo -e "  Docs:   ${CYAN}https://github.com/Acelogic/agentic-coding-flywheel-setup-simplified${NC}"
        ;;
    *) echo "Unknown: $1. Run 'flywheel help'" ;;
esac
